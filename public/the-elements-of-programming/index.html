<!doctype html>
<html
  lang="en"
  dir="ltr"
  class="scroll-smooth"
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    




<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="robots" content="index, follow" />
<meta
  name="googlebot"
  content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"
/>

<meta name="description" content="
SICP 원문에서 독자에게 이해시키고자 하는 개념을 최대한 살리고자 모든 단어를 번역하지 않았습니다. 어려운 단어는 구글링 하시면 금방 이해하실 수 있을 거라고 생각합니다.

A powerful programming language는 컴퓨터에게 명령하는 수단 그 이상의 의미를 가진다. 프로그래밍 언어라는 것은 우리가 명령하는 그 과정에 대한 아이디어들을 하나로 조합해주는 일종의 Framework로의 역할을 하기도 한다. 따라서 우리가 어떤 프로그래밍 언어를 설명할 때는, 해당 언어가 단순한 것들을 합쳐 더욱 복잡한 것을 형성하는 그러한 방법(Abstraction)을 어떻게 제공하는지 주목해야할 필요가 있다." />


<meta property="og:title" content="SICP: The Elements of Programming" />
<meta property="og:description" content="
SICP 원문에서 독자에게 이해시키고자 하는 개념을 최대한 살리고자 모든 단어를 번역하지 않았습니다. 어려운 단어는 구글링 하시면 금방 이해하실 수 있을 거라고 생각합니다.

A powerful programming language는 컴퓨터에게 명령하는 수단 그 이상의 의미를 가진다. 프로그래밍 언어라는 것은 우리가 명령하는 그 과정에 대한 아이디어들을 하나로 조합해주는 일종의 Framework로의 역할을 하기도 한다. 따라서 우리가 어떤 프로그래밍 언어를 설명할 때는, 해당 언어가 단순한 것들을 합쳐 더욱 복잡한 것을 형성하는 그러한 방법(Abstraction)을 어떻게 제공하는지 주목해야할 필요가 있다." />
<meta property="og:url" content="//localhost:1313/the-elements-of-programming/" />
<meta property="og:site_name" content="" />
<meta property="og:type" content="website" />
<meta property="og:image" content="//localhost:1313/images/og-image.png" />


<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="SICP: The Elements of Programming" />
<meta name="twitter:description" content="
SICP 원문에서 독자에게 이해시키고자 하는 개념을 최대한 살리고자 모든 단어를 번역하지 않았습니다. 어려운 단어는 구글링 하시면 금방 이해하실 수 있을 거라고 생각합니다.

A powerful programming language는 컴퓨터에게 명령하는 수단 그 이상의 의미를 가진다. 프로그래밍 언어라는 것은 우리가 명령하는 그 과정에 대한 아이디어들을 하나로 조합해주는 일종의 Framework로의 역할을 하기도 한다. 따라서 우리가 어떤 프로그래밍 언어를 설명할 때는, 해당 언어가 단순한 것들을 합쳐 더욱 복잡한 것을 형성하는 그러한 방법(Abstraction)을 어떻게 제공하는지 주목해야할 필요가 있다." />
<meta name="twitter:image" content="//localhost:1313/images/og-image.png" />

<title>SICP: The Elements of Programming</title>

    <link rel="stylesheet" href="/css/output.css" />


  </head>
  <body class="bg-white text-black antialiased">
    <section class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0">
      <div class="flex h-screen flex-col justify-between font-sans">
        <header
          class="flex items-center w-full bg-white justify-between py-10 sticky top-0 z-50"
        >
          <a class="group break-words" aria-label="" href="/blog">
  <div class="flex items-center justify-between">
    <div class="sm:mr-3">
      <img src="/blog/images/logo.svg" width="32" height="32" alt="Logo Image" />
    </div>

    <div class="hidden text-2xl font-semibold sm:block group-hover:underline">
      <span></span>
    </div>
  </div>
</a>

<div class="flex items-center space-x-4 leading-5 sm:space-x-6">
  <div class="items-center space-x-4 overflow-x-auto flex sm:space-x-6">
    
      <a
        href="mailto:youremail@email.com"
        class="font-medium text-gray-900 hover:text-indigo-500"
        
        >Contact</a
      >
    
      <a
        href="/tags"
        class="font-medium text-gray-900 hover:text-indigo-500"
        
        >Tags</a
      >
    
      <a
        href="/about"
        class="font-medium text-gray-900 hover:text-indigo-500"
        
        >About</a
      >
    
    <a href="https://github.com/nenjotsu" target="_blank">
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="currentColor"
        class="fill-[#24292F] hover:fill-indigo-500 h-6 w-6"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M12.0099 0C5.36875 0 0 5.5 0 12.3042C0 17.7432 3.43994 22.3472 8.21205 23.9767C8.80869 24.0992 9.02724 23.712 9.02724 23.3862C9.02724 23.101 9.00757 22.1232 9.00757 21.1045C5.6667 21.838 4.97099 19.6378 4.97099 19.6378C4.43409 18.2118 3.63858 17.8452 3.63858 17.8452C2.54511 17.0915 3.71823 17.0915 3.71823 17.0915C4.93117 17.173 5.56763 18.3545 5.56763 18.3545C6.64118 20.2285 8.37111 19.699 9.06706 19.373C9.16638 18.5785 9.48473 18.0285 9.82275 17.723C7.15817 17.4377 4.35469 16.3785 4.35469 11.6523C4.35469 10.3078 4.8316 9.20775 5.58729 8.35225C5.46807 8.04675 5.0504 6.7835 5.70677 5.09275C5.70677 5.09275 6.72083 4.76675 9.00732 6.35575C9.98625 6.08642 10.9958 5.9494 12.0099 5.94825C13.024 5.94825 14.0577 6.091 15.0123 6.35575C17.299 4.76675 18.3131 5.09275 18.3131 5.09275C18.9695 6.7835 18.5515 8.04675 18.4323 8.35225C19.2079 9.20775 19.6652 10.3078 19.6652 11.6523C19.6652 16.3785 16.8617 17.4172 14.1772 17.723C14.6148 18.11 14.9924 18.8433 14.9924 20.0045C14.9924 21.6545 14.9727 22.9788 14.9727 23.386C14.9727 23.712 15.1915 24.0992 15.7879 23.977C20.56 22.347 23.9999 17.7432 23.9999 12.3042C24.0196 5.5 18.6312 0 12.0099 0Z"
        />
      </svg>
    </a>
  </div>
</div>

        </header>
        <main class="mb-auto">
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "headline": "SICP: The Elements of Programming",
      "datePublished": "2025-03-23T00:00:00\u002b00:00",
      "dateModified": "2025-03-23T00:00:00\u002b00:00",
      "description": "\u003cblockquote\u003e\n\u003cp\u003eSICP 원문에서 독자에게 이해시키고자 하는 개념을 최대한 살리고자 모든 단어를 번역하지 않았습니다. 어려운 단어는 구글링 하시면 금방 이해하실 수 있을 거라고 생각합니다.\u003c\/p\u003e\n\u003c\/blockquote\u003e\n\u003cp\u003eA \u003cstrong\u003epowerful\u003c\/strong\u003e programming language는 컴퓨터에게 명령하는 수단 그 이상의 의미를 가진다. 프로그래밍 언어라는 것은 우리가 명령하는 그 과정에 대한 아이디어들을 하나로 조합해주는 일종의 \u003ccode\u003eFramework\u003c\/code\u003e로의 역할을 하기도 한다. 따라서 우리가 어떤 프로그래밍 언어를 설명할 때는, 해당 언어가 단순한 것들을 합쳐 더욱 복잡한 것을 형성하는 그러한 방법(Abstraction)을 어떻게 제공하는지 주목해야할 필요가 있다.\u003c\/p\u003e",
      "image": "/images/og-image.png",
      "url": "\/\/localhost:1313\/the-elements-of-programming\/",
      "author": [{ "@type": "Person", "name": "nenjotsu" }]
    }
  </script>
  <section class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0">
    <article>
      <div class="xl:divide-y xl:divide-gray-200">
        <header class="pt-6 xl:pb-6">
          <div class="space-y-1 text-center">
            <dl class="space-y-10">
              <div>
                <dt class="sr-only">Published on</dt>
                <dd class="text-base font-medium leading-6 text-gray-500">
                  
                  
                  <time datetime="2025-03-23T00:00:00&#43;00:00">Sunday, March 23, 2025</time>
                </dd>
              </div>
            </dl>
            <div>
              <h1
                class="text-3xl font-extrabold leading-9 tracking-tight text-gray-900 sm:text-4xl sm:leading-10 md:text-5xl md:leading-14"
              >
                <div>SICP: The Elements of Programming</div>
              </h1>
            </div>
          </div>
        </header>

        <div
          class="grid-rows-[auto_1fr] divide-y divide-gray-200 pb-8 xl:grid xl:grid-cols-4 xl:gap-x-6 xl:divide-y-0"
        >
          <dl class="pb-10 pt-6 xl:border-b xl:border-gray-200 xl:pt-11">
            <dt class="sr-only">Authors</dt>
            <dd>
              <ul
                class="flex flex-wrap justify-center gap-4 sm:space-x-12 xl:block xl:space-x-0 xl:space-y-8"
              >
                <li class="flex items-center space-x-2">
                  <img
                    src="https://github.com/nenjotsu.png"
                    class="rounded-full"
                    width="38"
                    height="38"
                    alt="Profile Image"
                    loading="lazy"
                  />
                  <dl class="whitespace-nowrap text-sm font-medium leading-5">
                    <dt class="sr-only">Name</dt>
                    <dd class="text-gray-900">nenjotsu</dd>
                  </dl>
                </li>
              </ul>
            </dd>
          </dl>

          <div
            class="divide-y divide-gray-200 xl:col-span-3 xl:row-span-2 xl:pb-0"
          >
            <div class="prose max-w-none pb-8 pt-10">
              <details open>
                <summary class="ml-6 pb-2 pt-2 text-xl font-bold">
                  <span>Table of Contents</span>
                </summary>

                <nav class="ml-6">
                    <ul>
                        <li><a href="#expressions">Expressions</a></li>
                        <li><a href="#naming-and-the-environment">Naming and the Environment</a></li>
                        <li><a href="#evaluating-combinations">Evaluating Combinations</a></li>
                        <li><a href="#compound-procedures">Compound Procedures</a></li>
                        <li><a href="#the-substitution-model-for-procedure-application">The Substitution Model for Procedure Application</a></li>
                        <li><a href="#applicative-order-vs-normal-order">Applicative Order vs. Normal Order</a></li>
                          <ul>
                              <li>
                                <a href="#applicative-order">Applicative Order</a>
                              </li>
                              <li>
                                <a href="#normal-order">Normal Order</a>
                              </li>
                          </ul>
                        <li><a href="#conditional-expressions-and-predicates">Conditional Expressions and Predicates</a></li>
                        <li><a href="#example-square-roots-by-newtons-method">Example: Square Roots by Newton’s Method</a></li>
                        <li><a href="#procedures-as-black-box-abstractions">Procedures as Black-Box Abstractions</a></li>
                          <ul>
                              <li>
                                <a href="#local-names">Local names</a>
                              </li>
                              <li>
                                <a href="#internal-definitions-and-block-structure">Internal definitions and block structure</a>
                              </li>
                          </ul>
                        <li><a href="#%ec%a0%95%eb%a6%ac">정리</a></li>
                    </ul>
                </nav>
              </details>

              <blockquote>
<p>SICP 원문에서 독자에게 이해시키고자 하는 개념을 최대한 살리고자 모든 단어를 번역하지 않았습니다. 어려운 단어는 구글링 하시면 금방 이해하실 수 있을 거라고 생각합니다.</p>
</blockquote>
<p>A <strong>powerful</strong> programming language는 컴퓨터에게 명령하는 수단 그 이상의 의미를 가진다. 프로그래밍 언어라는 것은 우리가 명령하는 그 과정에 대한 아이디어들을 하나로 조합해주는 일종의 <code>Framework</code>로의 역할을 하기도 한다. 따라서 우리가 어떤 프로그래밍 언어를 설명할 때는, 해당 언어가 단순한 것들을 합쳐 더욱 복잡한 것을 형성하는 그러한 방법(Abstraction)을 어떻게 제공하는지 주목해야할 필요가 있다.</p>
<p>우리가 <strong>powerful</strong>하다고 부를 수 있는 language에는 다음 세 가지의 메커니즘을 가지고 있다.</p>
<ul>
<li><strong>primitive expressions</strong>: 언어에서 다루는 가장 단순한 개념을 나타내는 것</li>
<li><strong>means of combination</strong>: 단순한 요소(element)들을 조합하여 복합적인 요소를 구성하는 방법을 제공하는 것</li>
<li><strong>means of abstraction</strong>: 만들어진 복합적인 요소에 이름을 부여할 수 있고, 그것을 하나의 단위로 다룰 수 있게 제공하는 것</li>
</ul>
<p>프로그래밍에서는 두 종류의 요소를 다룬다. 하나는 <code>procedures</code>와 다른 하나는 <code>data</code>이다(나중 가면 둘이 크게 별반 다르지 않다는 것을 알 수 있음). data는 말 그대로 데이터 혹은 그냥 어떠한 것이라고 표현할 수 있다. procedure는 data를 조작할 수 있게 규칙을 설명해주는 것이다.</p>
<p>결국 프로그래밍 언어라는 것은 <code>primitive data</code>와 <code>primitive procedure</code>을 설명할 수 있고, 이걸 combining 하거나 abstracting 할 수 있는 방법을 제공해주면 되는 것이다.</p>
<h2 id="expressions">Expressions</h2>
<blockquote>
<p>Lisp의 dialect인 <code>Scheme</code>에 대해서 일부 표현 방식을 설명</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(+ <span style="color:#ae81ff">137</span> <span style="color:#ae81ff">349</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">486</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(/ <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(+ <span style="color:#ae81ff">2.7</span> <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12.7</span>
</span></span></code></pre></div><p>표현식(Expression)이란 이런 것들이다. 여기서는 괄호 안의 맨 왼쪽 요소에는 <em>operator</em>가 위치해 있고 그 오른쪽에 나머지 요소들이 <em>operand</em>들이 위치해있다. 이것을 조합식(Combination)이라고 한다. Scheme에서는 operator가 맨 왼쪽으로 가는 <em>prefix notation</em> 방식(Convention)을 따른다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(+ <span style="color:#ae81ff">21</span> <span style="color:#ae81ff">35</span> <span style="color:#ae81ff">12</span> <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">75</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(+ (* <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">5</span>) (- <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19</span>
</span></span></code></pre></div><p>prefix notation으로 작성하면 모호함이 전혀 없고, <em>nested</em>하게 작성해도 바로 이해하기 쉬운 장점이 있다.</p>
<h2 id="naming-and-the-environment">Naming and the Environment</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>size <span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>이는 변수(variable)를 사용하는 방법이다.</p>
<p>프로그래밍 언어의 가장 중요한 점 중 하나는 이렇게 이름을 정해서 computational objects에 가리킬 수 있게 해주는 것이다.</p>
<p>예제:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>pi <span style="color:#ae81ff">3.14159</span>)
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>radius <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(* pi (* radius radius))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">314.159</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>circumference (* <span style="color:#ae81ff">2</span> pi radius))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>circumference
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">62.8318</span>
</span></span></code></pre></div><p>위에서 살펴본 <code>define</code>은 이 언어의 가장 기본적인 추상화의 한 방법이다. 우리가 선언한 변수(pi, radius, circumference)는 memory에 유지되는데 이걸 <em>environment</em>라고 부른다.(정확히는 <em>global environment</em>라고 부름)</p>
<h2 id="evaluating-combinations">Evaluating Combinations</h2>
<p>조합식을 평가(즉, 계산하는)하는 방법은 다음 과정을 따른다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(+ <span style="color:#ae81ff">21</span> <span style="color:#ae81ff">35</span> <span style="color:#ae81ff">12</span> <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">75</span>
</span></span></code></pre></div><ol>
<li>조합식의 subexpressions을 계산한다.</li>
<li>가장 왼쪽의 subexpression인 operator를 가지고 오른쪽에 있는 subexpressions인 operands에 procedure를 수행한다.</li>
</ol>
<p>조금 더 복잡한 식으로 가보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(* (+ <span style="color:#ae81ff">2</span> (* <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">6</span>)) (+ <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">7</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">390</span>
</span></span></code></pre></div><p>위 식은 어떻게 계산이 될까?</p>
<p><img src="1.png" alt=""></p>
<p>위 식은 총 4개의 조합식이 계산되어야 한다. 이 과정을 트리 구조로 표현하면서 얻을 수 있다. 보면서 아마 트리 같은 계층적인 구조에 <em>recursion</em>이 강력한 기술이라는 걸 알게 될 수 있다.</p>
<h2 id="compound-procedures">Compound Procedures</h2>
<p>이제 우리는 <code>procedure</code>가 뭔지 알아볼 것이다. 이는 복합적인 연산에 이름을 붙이고 이를 하나의 단위로 사용할 수 있게 하는 아주 강력한 추상화 기법이다. (근데 사실 이미 function이라는 아름으로 우리는 쉽게 바로 이해할 수 있음)</p>
<p>???: 제곱을 하기 위해서는 그 수를 서로 곱하세요!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">square</span> x) (* x x))
</span></span></code></pre></div><p>이렇게 표현할 수 있다. 우리는 이 compound procedure에 square라는 이름을 붙여줬다. 이 procedure를 다음과 같이 사용할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">square</span> <span style="color:#ae81ff">21</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">441</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">square</span> (+ <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">5</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">49</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">square</span> (<span style="color:#a6e22e">square</span> <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">81</span>
</span></span></code></pre></div><p>또 다음과 같이 사용할 수도 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(+ (<span style="color:#a6e22e">square</span> x) (<span style="color:#a6e22e">square</span> y))
</span></span></code></pre></div><p>위는 x^2 + y^2를 표현한 식이다. <code>sum-of-squares</code>라는 procedure를 하나 더 만들어보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sum-of-squares</span> x y)
</span></span><span style="display:flex;"><span>  (+ (<span style="color:#a6e22e">square</span> x) (<span style="color:#a6e22e">square</span> y)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">sum-of-squares</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">25</span>
</span></span></code></pre></div><p>이렇게 x^2 + y^2를 <code>sum-of-squares</code>로 정의해줄 수 있다. 한 단계 나아가서 다음과 같은 procedure를 만들고 살펴보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">f</span> a)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">sum-of-squares</span> (+ a <span style="color:#ae81ff">1</span>) (* a <span style="color:#ae81ff">2</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">f</span> <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">136</span>
</span></span></code></pre></div><p>Compound procedures는 위에서 앞서 살펴본 +, *와 같은 primitive procedure와 동일하게 사용하면 된다. 정말 누군가 <code>sum-of-squares</code>를 보고 +, *와 같은 이런 사칙연산처럼 이미 내장되어있는지 알 수 없다.</p>
<h2 id="the-substitution-model-for-procedure-application">The Substitution Model for Procedure Application</h2>
<p>이 코드를 실행하는 <code>interpreter</code>는 다음처럼 동작한다고 추측할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">f</span> <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; f의 body는 아래와 같다<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">sum-of-squares</span> (+ a <span style="color:#ae81ff">1</span>) (* a <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; a에 <span style="color:#ae81ff">5</span>를 대입한다<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">sum-of-squares</span> (+ <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>) (* <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>))
</span></span></code></pre></div><p>우리는 이렇게 <code>sum-of-squares</code>라는 operator와 <code>(+ 5 1)</code>, <code>(* 5 2)</code>라는 operands가 남았다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(+ (<span style="color:#a6e22e">square</span> <span style="color:#ae81ff">6</span>) (<span style="color:#a6e22e">square</span> <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; square의 정의를 통해 다음으로 바꿀 수 있다<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(+ (* <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">6</span>) (* <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; 이는 다음과 같이 계산될 수 있다<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(+ <span style="color:#ae81ff">36</span> <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; 그리고 마지막으로
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">136</span>
</span></span></code></pre></div><p>이러한 과정들을 <em>substitution model</em> for procedure application이라고 부른다.</p>
<h2 id="applicative-order-vs-normal-order">Applicative Order vs. Normal Order</h2>
<p>위에서 우리는 먼저 operator와 operands를 이용하여 계산을 하고, 그 값을 그 다음 procedure에 대입하여 계산을 했다. 이 계산 방법은 Applicative Order라고 부른다. 다만, 계산 방식에는 이것만이 있는 것이 아니다.</p>
<p>다른 방법으로는 operands를 필요하기 전까지 계산하지 않고 마지막에 계산하는 방식이 있다.(아래 예제를 보는 게 더 빠르다.) 아래는 Applicative Order와 Normal Order가 어떻게 다른지 간단한 식이 주어진다.</p>
<h3 id="applicative-order">Applicative Order</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">sum-of-squares</span> (+ <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>) (* <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">sum-of-squares</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(+ (<span style="color:#a6e22e">square</span> <span style="color:#ae81ff">6</span>) (<span style="color:#a6e22e">square</span> <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(+ (* <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">6</span>) (* <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(+ <span style="color:#ae81ff">36</span> <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">136</span>
</span></span></code></pre></div><h3 id="normal-order">Normal Order</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#a6e22e">sum-of-squares</span> (+ <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>) (* <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(+ (<span style="color:#a6e22e">square</span> (+ <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>)) (<span style="color:#a6e22e">square</span> (* <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>)))
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(+ (* (+ <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>) (+ <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>)) (* (* <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>) (* <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">2</span>)))
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(+ (* <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">6</span>) (* <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>(+ <span style="color:#ae81ff">36</span> <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">136</span>
</span></span></code></pre></div><p>이게 바로 Normal Order 방식이다. 결과는 이전 evaluation model인 applicative order와 동일한 결과를 준다. 하지만 보다시피 <code>(+ 5 1)</code>, <code>(* 5 2)</code> 이 계산이 두 번 반복됐다.</p>
<p>Applicative Order의 경우 Eager Evaluation(즉시 평가) 방식이 사용돠고, Normal Order의 경우 Lazy Evaluation(지연 평가) 방식이 사용된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">heavy_computation</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Computing...&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">applicative_example</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(applicative_example(heavy_computation()))
</span></span></code></pre></div><p>조금 더 친숙한 위 파이썬 코드를 살펴보자. Applicative Order은 어떻게 동작할까?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 1. heavy_computation()을 먼저 실행 → &#34;Computing...&#34; 출력</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 결과값 42를 x에 대입</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. x + x → 42 + 42 = 84</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(applicative_example(heavy_computation()))
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Computing<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>print(applicative_example(<span style="color:#ae81ff">42</span>))
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#ae81ff">42</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#ae81ff">84</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">84</span>
</span></span></code></pre></div><p>반면에 Normal Order은 어떻게 동작할까?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print(applicative_example(heavy_computation()))
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>print(heavy_computation() <span style="color:#f92672">+</span> heavy_computation())
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Computing<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>Computing<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#ae81ff">42</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#ae81ff">84</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">84</span>
</span></span></code></pre></div><p>예상할 수 있듯이 Normal Order은 Applicative Order에 비해 느리다. 대부분의 현대 언어에서는 함수에 대해서 Applicative Order를 사용하고 있다.</p>
<p>다만, Lazy Evaluation에 대해서는 느리다고 버릴 이유가 없다. 이미 중요한 곳에서 많이 활용되고 있다.</p>
<p>예를 들면, <code>if (a || b)</code> 같은 조건문이 있다고 보자. 여기서 a가 충족되면 b는 살펴볼 필요도 없다. 이런 게 Lazy Evalutation이다.</p>
<h2 id="conditional-expressions-and-predicates">Conditional Expressions and Predicates</h2>
<p>다른 언어와 같은 조건문, 논리 연산 파트이다. 아래 예제를 보고 빠르게 넘어가자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(abs x)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">cond </span>((&gt; x <span style="color:#ae81ff">0</span>) x)
</span></span><span style="display:flex;"><span>  ((= x <span style="color:#ae81ff">0</span>) <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  ((&lt; x <span style="color:#ae81ff">0</span>) (- x))))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(abs x)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">cond </span>((&lt; x <span style="color:#ae81ff">0</span>) (- x))
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">else </span>x)))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(abs x)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">if </span>(&lt; x <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    (- x)
</span></span><span style="display:flex;"><span>  x))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">and </span>(&gt; x <span style="color:#ae81ff">5</span>) (&lt; x <span style="color:#ae81ff">10</span>))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(&gt;= x y) (<span style="color:#66d9ef">or </span>(&gt; x y) (= x y)))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(&gt;= x y) (not (&lt; x y)))
</span></span></code></pre></div><p>문법을 설명하고자 글을 쓰는 것은 아니니 알아서 이해하면 좋겠다..</p>
<h2 id="example-square-roots-by-newtons-method">Example: Square Roots by Newton’s Method</h2>
<p>앞서 설명한 Procedures는 일반적인 수학에서 사용하는 함수와 비슷하다. 하나 이상의 parameters로 값을 계산하고 결과를 받아온다. 하지만, 수학에서의 functions와 computer procedures에는 중요한 차이가 있다. 다음을 같이 보자.</p>
<p>Square root 함수의 수학적 정의는 다음과 같이 내릴 수 있다.</p>
<blockquote>
<p>√x = the y such that y ≥0 and y^2 = x .</p>
</blockquote>
<p>위는 수학에서 sqaure root 함수에 대한 정의다. 하지만 procedure에서 가장 중요한 <strong>과정</strong>을 설명하지 않는다.</p>
<p>이는 수학적 함수 정의는 what에 집중한 declarative descriptions인 것이고, procedure에서는 그 과정(how to)을 위한 imperative descriptions가 필요하다.</p>
<p>그래서 컴퓨터는 square root를 어떻게 계산할까? 가장 common한 방법으로는 Newton’s method of successive approximations를 이용하는 것이다. Newton-Raphson Method로도 유명하다.</p>
<p>…</p>
<p>2의 제곱근을 구하는 방법</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>Guess Quotient Average
</span></span><span style="display:flex;"><span>1 (2/1) = 2 ((2 + 1)/2) = 1.5
</span></span><span style="display:flex;"><span>1.5 (2/1.5) = 1.3333 ((1.3333 + 1.5)/2) = 1.4167
</span></span><span style="display:flex;"><span>1.4167 (2/1.4167) = 1.4118 ((1.4167 + 1.4118)/2) = 1.4142
</span></span><span style="display:flex;"><span>1.4142 ... ...
</span></span></code></pre></div><p>이런 과정을 하다보면 2의 제곱근에 가까운 값을 구할 수 있다. 이 과정을 Procedure로 나타내보자.</p>
<p>구하려고 하는 radicand x(여기서는 2)와 그 결과값 guess를 가지고 계산한다. guess가 충분하다면 계산을 끝내고, 아니면 그 과정을 반복하면 된다. 우선, 간단한 계산을 시작해보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sqrt-iter</span> guess x)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
</span></span><span style="display:flex;"><span>    guess
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">sqrt-iter</span> (<span style="color:#a6e22e">improve</span> guess x)
</span></span><span style="display:flex;"><span>               x)))
</span></span></code></pre></div><p>guess 값과 x를 guess로 나눈 값의 평균(/ x guess)을 내서 제곱근에 더 가까운 값을 계산할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">average</span> x y)
</span></span><span style="display:flex;"><span>  (/ (+ x y) <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">improve</span> guess x)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">average</span> guess (/ x guess)))
</span></span></code></pre></div><p>우리가 <em>good enough</em>하게 판단할 수 있는 정도도 정해야 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
</span></span><span style="display:flex;"><span>  (&lt; (abs (- (<span style="color:#a6e22e">square</span> guess) x)) <span style="color:#ae81ff">0.001</span>))
</span></span></code></pre></div><p>이는 제곱근의 오차가 0.001을 넘지 않을 때까지 근사값을 찾는 것이다. 마지막으로 이 값을 계산하는 프로시저를 만들면 된다. 우선, 제곱근에 가까운 값(guess)은 1을 쓰기로 하자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(sqrt x)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">sqrt-iter</span> <span style="color:#ae81ff">1.0</span> x))
</span></span></code></pre></div><p>한번 돌려볼까요?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(sqrt <span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.00009155413138</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(sqrt (+ <span style="color:#ae81ff">100</span> <span style="color:#ae81ff">37</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11.704699917758145</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(sqrt (+ (sqrt <span style="color:#ae81ff">2</span>) (sqrt <span style="color:#ae81ff">3</span>)))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.7739279023207892</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#a6e22e">square</span> (sqrt <span style="color:#ae81ff">1000</span>))
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1000.000369924366</span>
</span></span></code></pre></div><h2 id="procedures-as-black-box-abstractions">Procedures as Black-Box Abstractions</h2>
<p>우리는 <code>sqrt-iter</code>를 <em>recursive</em>(재귀)하게 만들었다. procedure을 정의하면서 자기 자신을 사용하도록 만든 것이다.</p>
<p><img src="2.png" alt=""></p>
<p><code>sqrt</code>는 위 그림과 같이 문제를 작게 나누어 procedure을 여러개 구성하고 하나로 다시 구성했다.</p>
<p>Procedure을 나누고 구성할 때는 단순히 작은 조각으로 나누는 것이 아니다. 이후에는 이보다 더욱 크고 다양한 동작을 하는 하나의 프로그램으로 만들 때를 고려하기 위해 각 procedure가 어떤 일을 하는지 명확히 할 필요가 있고, 결국 그게 잘 만들어진 <code>module</code>이 될 것이다.</p>
<p>우리는 <code>square</code>을 만들 때 값을 <strong>어떻게</strong> 구하는지는 몰라도 어쨌든 제곱값을 내놓는다는 걸 안다. 이것은 결국 블랙바스와도 같은 것이다.</p>
<h3 id="local-names">Local names</h3>
<p>procedure을 만들 때는 그걸 사용하는 사용자에게 아무런 영향이 없어야 한다. 다음 두 procedure는 구분할 수 없다.(= 똑같다)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">square</span> x) (* x x))
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">square</span> y) (* y y))
</span></span></code></pre></div><p>procedure의 prarmeter 이름이 독립적이어야 한다. (번역서: 프로시저의 매개변수 이름이 프로시저가 뜻하는 바에 영향을 주지 않아야 한다.)</p>
<blockquote>
<p>원서나 번역서나 곧바로 이 뜻을 이해하기 어렵다.</p>
</blockquote>
<p>결국 이것이 뜻하는 의미는 parameter는 해당 procedure에 종속되어 있다. 혹은 local variable로 사용되어야 한다는 의미다.</p>
<blockquote>
<p>이게 functional programming의 중요한 원칙 중 하나로 알고 있다. procedure 자체가 외부 어느 곳에도 영향을 줄 수 없으며(no side-effects), 그 자체 하나로 <strong>Pure Function</strong>이다.</p>
</blockquote>
<h3 id="internal-definitions-and-block-structure">Internal definitions and block structure</h3>
<p>우리는 지금까지 프로시저를 다 따로따로 정의해왔다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(sqrt x)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">sqrt-iter</span> <span style="color:#ae81ff">1.0</span> x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sqrt-iter</span> guess x)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
</span></span><span style="display:flex;"><span>    guess
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">sqrt-iter</span> (<span style="color:#a6e22e">improve</span> guess x) x)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">good-enough?</span> guess x)
</span></span><span style="display:flex;"><span>  (&lt; (abs (- (<span style="color:#a6e22e">square</span> guess) x)) <span style="color:#ae81ff">0.001</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">improve</span> guess x)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">average</span> guess (/ x guess)))
</span></span></code></pre></div><p>다만, 이 procedure를 사용하는 쪽에서는 <code>sqrt</code> 이것만 있으면 된다. <code>sqrt-iter</code>, <code>good-enough?</code>, <code>improve</code>는 <code>sqrt</code>를 사용하는 입장에서 헷갈리게 만든다. 그리고 새롭게 <code>sqrt-iter</code>, ~~등의 프로시저를 새롭게 만들고 싶을 때에 이미 있기 때문에 만들어 쓸 수 없다. <code>sqrt</code>에서 이미 사용하고 있기 때문이다.</p>
<p>그래서 우리는 이를 숨길 수 있어야 한다. 바로 <code>sqrt</code> 안에 숨겨서 말이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scheme" data-lang="scheme"><span style="display:flex;"><span><span style="color:#66d9ef">define </span>(sqrt x)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">good-enough?</span> guess)
</span></span><span style="display:flex;"><span>    (&lt; (abs (- (<span style="color:#a6e22e">square</span> guess) x)) <span style="color:#ae81ff">0.001</span>))
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">improve</span> guess)
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">average</span> guess (/ x guess)))
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">define </span>(<span style="color:#a6e22e">sqrt-iter</span> guess)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">good-enough?</span> guess)
</span></span><span style="display:flex;"><span>      guess
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">sqrt-iter</span> (<span style="color:#a6e22e">improve</span> guess))))
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">sqrt-iter</span> <span style="color:#ae81ff">1.0</span>))
</span></span></code></pre></div><p>이렇게 procedure의 definition을 nested한 걸 <em>block structure</em>라고 부른다. 그리고 사실 이전에 만든 procedure와 달리 define에서 <code>x</code>를 다 제거했는데 이는 <code>sqrt</code>에서 들어온 <code>x</code>를 바로 그 하위 procedure의 body 안에서 binding 할 수 있기 때문이다. 이를 <em>lexical scoping</em>이라고 부를 수 있다.</p>
<h2 id="정리">정리</h2>
<ol>
<li><strong>기본 표현식</strong>: 숫자, 연산자(<code>+</code>, <code>*</code>), 변수 정의(<code>define</code>).</li>
</ol>
<ul>
<li>예: <code>(define x 10)</code>, <code>(+ 3 4)</code>.</li>
</ul>
<ol start="2">
<li><strong>프로시저 정의</strong>: 함수를 만들고 호출.</li>
</ol>
<ul>
<li>예: <code>(define (square x) (* x x))</code>.</li>
</ul>
<ol start="3">
<li><strong>치환 모델(Substitution Model)</strong>: 함수 호출이 어떻게 계산되는지.</li>
</ol>
<ul>
<li><code>(square 3)</code> → <code>(* 3 3)</code> → <code>9</code>.</li>
</ul>
<ol start="4">
<li><strong>조건과 논리</strong>: (if), (cond)로 분기.</li>
</ol>
<ul>
<li>예: <code>(if (&gt; x 0) x (- x))</code>.</li>
</ul>
<p>정의: 프로그래밍은 값, 연산, 함수로 계산을 표현하는 과정.</p>

            </div><div class="py-6 text-sm text-gray-700">
                <script
                  src="https://giscus.app/client.js"
                  data-repo="[ENTER REPO HERE]"
                  data-repo-id="[ENTER REPO ID HERE]"
                  data-category="[ENTER CATEGORY NAME HERE]"
                  data-category-id="[ENTER CATEGORY ID HERE]"
                  data-mapping="pathname"
                  data-strict="0"
                  data-reactions-enabled="1"
                  data-emit-metadata="0"
                  data-input-position="bottom"
                  data-theme="light"
                  data-lang="en"
                  crossorigin="anonymous"
                  async
                ></script>
              </div>
            
          </div>

          <footer>
            <div
              class="divide-gray-200 text-sm font-medium leading-5 xl:col-start-1 xl:row-start-2 xl:divide-y"
            >
              <div class="py-4 xl:py-8">
                <h2 class="text-xs uppercase tracking-wide text-gray-500">
                  Tags
                </h2>
                <div class="flex flex-wrap">
                  
                </div>
              </div>
            </div>

            <div class="pt-4 xl:pt-8">
              <a
                class="text-indigo-500 hover:text-indigo-600"
                aria-label="Back to the list"
                href="/blog"
                >← Back to the list</a
              >
            </div>
          </footer>
        </div>
      </div>
    </article>
  </section>
</main>
        <footer><div class="mt-16 flex flex-col items-center">
  <div class="mb-2 text-sm text-gray-500">
    <span>(C) 2025.  all rights reserved.</span>
  </div>

  <div class="mb-8 text-sm text-gray-500">
    <span class="mr-1">Built with</span>
    <a
      class="font-semibold underline"
      href="https://github.com/discaptive/hugo-discaptive"
      target="_blank"
      >hugo-discaptive</a
    >
  </div>
</div>
</footer>
      </div>
    </section>
  </body>
</html>
